use std::collections::HashMap;
use std::fmt;

use std::backtrace::Backtrace;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug)]
pub struct Error {
    /// Primary error message
    message: String,
    /// Error code (optional)
    code: Option<i32>,
    /// Stack trace captured at error creation (optional for performance)
    backtrace: Option<Backtrace>,
    /// Additional metadata
    metadata: HashMap<String, String>,
    /// Source error chain (using std::error::Error trait)
    source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
}

impl Error {
    /// Create a new error with a message
    pub fn new(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
            code: None,
            backtrace: None,
            metadata: HashMap::new(),
            source: None,
        }
    }

    /// Get the error message
    pub fn message(&self) -> &str {
        &self.message
    }

    /// Get the error code
    pub fn code(&self) -> Option<i32> {
        self.code
    }

    /// Get the metadata
    pub fn metadata(&self) -> &HashMap<String, String> {
        &self.metadata
    }

    /// Set custom error code
    pub fn with_code(mut self, code: i32) -> Self {
        self.code = Some(code);
        self
    }

    pub fn with_backtrace(mut self) -> Self {
        self.backtrace = Some(Backtrace::capture());
        self
    }

    /// Add metadata to the error
    ///
    /// Metadata provides additional context about the error that can be useful
    /// for debugging, logging, or error handling. This method can be chained
    /// to add multiple metadata entries.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use altria::error::Error;
    /// let error = Error::validation("Invalid input")
    ///     .with_metadata("field", "email")
    ///     .with_metadata("value", "invalid@")
    ///     .with_metadata("rule", "email_format");
    ///
    /// assert_eq!(error.metadata().get("field"), Some(&"email".to_string()));
    /// ```
    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.metadata.insert(key.into(), value.into());
        self
    }

    /// Add multiple metadata entries
    pub fn with_metadata_map(mut self, metadata: HashMap<String, String>) -> Self {
        self.metadata.extend(metadata);
        self
    }

    /// Chain with source error
    ///
    /// This method allows you to create an error chain by setting a source error.
    /// The source error must implement `std::error::Error + Send + Sync + 'static`.
    /// This integrates with Rust's standard error handling mechanisms.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use altria::error::Error;
    /// use std::io;
    /// use std::error::Error as StdError; // Import trait for source() method
    ///
    /// let io_error = io::Error::new(io::ErrorKind::NotFound, "File not found");
    /// let app_error = Error::config("Failed to load config")
    ///     .with_source(io_error);
    ///
    /// // You can traverse the error chain using std::error::Error::source()
    /// assert!(app_error.source().is_some());
    /// ```
    pub fn with_source<E>(mut self, source: E) -> Self
    where
        E: std::error::Error + Send + Sync + 'static,
    {
        self.source = Some(Box::new(source));
        self
    }

    // Error kind checking methods generated by macro above

    /// Get error chain using std::error::Error's source mechanism
    ///
    /// This method returns a vector of all errors in the chain, starting with
    /// the current error and following the source chain. This is the standard
    /// way to traverse error chains in Rust.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use altria::error::Error;
    /// let source = Error::io("File not found");
    /// let main_error = Error::config("Config load failed")
    ///     .with_source(source);
    ///
    /// let chain: Vec<_> = main_error.iter_error_chain().collect();
    /// assert_eq!(chain.len(), 2);
    /// // chain[0] is the main_error
    /// // chain[1] is the source error
    /// ```
    pub fn iter_error_chain(&self) -> ErrorChainIter<'_> {
        ErrorChainIter {
            current: Some(self),
        }
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // 1. Error code (if present)
        if let Some(code) = &self.code {
            writeln!(f, "Code: {code}")?;
        }

        // 2. Error message
        writeln!(f, "Error: {}", self.message)?;

        // 3. Metadata (if present)
        if !self.metadata.is_empty() {
            writeln!(f, "Metadata:")?;
            for (key, value) in &self.metadata {
                writeln!(f, "  {key}: {value}")?;
            }
        }

        // 4. Stack trace (if captured)
        if let Some(backtrace) = &self.backtrace {
            writeln!(f, "Backtrace:")?;
            writeln!(f, "{}", backtrace)?;
        }

        // 5. Source error chain
        if let Some(source) = &self.source {
            writeln!(f, "Caused by:")?;
            let source_str = format!("{source}");
            for line in source_str.lines() {
                writeln!(f, "  {line}")?;
            }
        }

        Ok(())
    }
}

impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        self.source
            .as_deref()
            .map(|e| e as &(dyn std::error::Error + 'static))
    }
}

/// An iterator over an error and its sources.
pub struct ErrorChainIter<'a> {
    current: Option<&'a (dyn std::error::Error + 'static)>,
}

impl<'a> Iterator for ErrorChainIter<'a> {
    type Item = &'a (dyn std::error::Error + 'static);

    fn next(&mut self) -> Option<Self::Item> {
        let current_error = self.current;
        if let Some(error) = current_error {
            self.current = error.source();
        }
        current_error
    }
}
